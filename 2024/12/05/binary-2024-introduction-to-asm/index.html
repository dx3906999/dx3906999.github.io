<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/xme.png"><link rel="icon" href="/img/xme.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="dx3qOb"><meta name="keywords" content=""><meta name="description" content="2024秋UCASCTF小组binary方向汇编部分讲义之一。在这节课，你将会了解到汇编语言的基本概念，有关寄存器与内存的相关知识，并动手实践，了解汇编语言与c语言的一些对应关系。"><meta property="og:type" content="article"><meta property="og:title" content="汇编简介"><meta property="og:url" content="https://dx3906999.github.io/2024/12/05/binary-2024-introduction-to-asm/index.html"><meta property="og:site_name" content="dx3qOb&#39;s blog"><meta property="og:description" content="2024秋UCASCTF小组binary方向汇编部分讲义之一。在这节课，你将会了解到汇编语言的基本概念，有关寄存器与内存的相关知识，并动手实践，了解汇编语言与c语言的一些对应关系。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://dx3906999.github.io/2024/12/05/binary-2024-introduction-to-asm/659280-20201021092122855-1111960429.png"><meta property="article:published_time" content="2024-12-05T12:40:15.000Z"><meta property="article:modified_time" content="2024-12-05T12:52:53.374Z"><meta property="article:author" content="dx3qOb"><meta property="article:tag" content="binary"><meta property="article:tag" content="pwn"><meta property="article:tag" content="ctf"><meta property="article:tag" content="asm"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://dx3906999.github.io/2024/12/05/binary-2024-introduction-to-asm/659280-20201021092122855-1111960429.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>汇编简介 - dx3qOb&#39;s blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"dx3906999.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>dx3qOb&#39;s blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/messageboard/" target="_self"><i class="iconfont icon-speakernotes"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bg/fll.jpeg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.7)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="汇编简介"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-12-05 20:40" pubdate>2024年12月5日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 23 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="binary" id="heading-9d7183f16acce70658f686ae7f1a4d20" role="tab" data-toggle="collapse" href="#collapse-9d7183f16acce70658f686ae7f1a4d20" aria-expanded="true">binary <span class="list-group-count">(2)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-9d7183f16acce70658f686ae7f1a4d20" role="tabpanel" aria-labelledby="heading-9d7183f16acce70658f686ae7f1a4d20"><div class="category-post-list"><a href="/2024/12/05/binary-2024-stack-and-function/" title="栈与函数" class="list-group-item list-group-item-action"><span class="category-post">栈与函数</span> </a><a href="/2024/12/05/binary-2024-introduction-to-asm/" title="汇编简介" class="list-group-item list-group-item-action active"><span class="category-post">汇编简介</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">汇编简介</h1><div class="markdown-body"><h2 id="基本概念">基本概念</h2><p><strong>指令</strong>：即控制cpu的指令，相当于一个或一串对cpu有意义的字节。不同设计的cpu会有不同的指令架构（这与硬件有关）。</p><p><strong>机器码</strong>：cpu能直接执行的一个或一串字节。</p><p><strong>汇编语言</strong>：是机器码的助记符。</p><p><strong>寄存器</strong>：在cpu中的、可以快速访问的少量存储器。</p><p>不同的cpu有不同的指令集，对应的汇编语言也有不同的语法，使用的寄存器也不同。（比如intel的x86、x64架构，ARMv8架构，mips架构，在接下来的课程中，我们着重于x86、x64架构的汇编讲解）</p><p>同一架构下汇编语言的语法也可能有所不同，比如x64有AT&amp;T语法、intel风格语法。此外，不同编译器之间也有一些较小的差异，比如masm和nasm。</p><p>下面给出上面四个概念的对应例子：</p><p><strong>intel</strong>语法风格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nasm">push rbp    ; 0x55<br>nop         ; 0x90<br></code></pre></td></tr></table></figure><p>上面的汇编语言片段中，<code>push rbp</code> 是一条汇编指令，它对应的机器码是 <code>0x55</code> ，它的含义是将 <code>rbp</code> 寄存器中的值压入栈中。</p><p><strong>AT&amp;T</strong>语法风格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembler">pushq %rbp<br>nop<br></code></pre></td></tr></table></figure><p>基于方便的理由，我们这节课暂且以nasm编译器、intel风格语法为例编写汇编程序。</p><h2 id="nasm编译器的安装和使用">nasm编译器的安装和使用</h2><ul><li><p>ubuntu:</p><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install nasm<br></code></pre></td></tr></table></figure><p></p></li><li><p>windows:</p><p><a target="_blank" rel="noopener" href="https://www.nasm.us/pub/nasm/releasebuilds/2.16.03/win64/">官网下载地址</a></p><p>下载后添加到系统PATH环境变量</p></li></ul><p>检查 ： <code>nasm --version</code></p><p>新建一个文件 <code>hello.asm</code> ，输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nasm">; Intel 格式<br>; Hello.asm<br>section .data           ; 数据段声明<br>          msg db &quot;Hello World!&quot;,0xA   ; 要输出的字符串<br>          len equ $ -msg              ; 字符串长度<br>section .text                         ; 代码段声明<br>global _start                         ; 指定入口函数<br>_start:                               ; 在屏幕上显示一个字符串<br>          mov edx, len                ; 参数三：字符串长度<br>          mov ecx, msg                ; 参数二：要显示的字符串<br>          mov ebx, 1                  ; 参数一：文件描述符（stdout）<br>          mov eax, 4                  ; 系统调用号（sys_write）<br>          int 0x80                    ; 调用内核功能<br>                                      ; 退出程序<br>          mov ebx, 1                  ; 参数一：退出代码<br>          mov eax, 1                  ; 系统调用号（sys_exit）<br>          int 0x80                    ; 调用内核功能<br></code></pre></td></tr></table></figure><p>保存退出后，在终端输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nasm -f elf64 helloworld.asm -o hello.o<br>ld hello.o -o hello<br></code></pre></td></tr></table></figure><p>即可生成可执行文件 <code>hello</code> ，执行它，将会打印一条helloworld</p><h2 id="认识寄存器">认识寄存器</h2><p>在x86架构中，寄存器通常分为以下几类： - 通用寄存器 - 标志寄存器 - 指令寄存器 - 段寄存器 - ...</p><p>（还有一些寄存器目前涉及不到，上面几个是现阶段逆向最常用的）</p><p>至于x64架构，只是将上面一些寄存器进行了拓展。</p><h3 id="通用寄存器">通用寄存器</h3><p>x86系统通用寄存器有如下几个：</p><ul><li>eax 通常是和函数的返回值</li><li>ebx 一般用来做数据存取</li><li>ecx 通常用来作为计数器</li><li>edx 乘除运算的默认操作数，也可以用作IO端口</li><li>edi 通常与字符串操作有关</li><li>esi 通常与字符串操作有关</li><li>esp 栈顶寄存器</li><li>ebp 栈基址寄存器</li></ul><p>当然，上面所述都是其常用功能，即高级语言编译器的用法，这几个寄存器也可以做另外用途，自己写汇编的时候不一定遵守其通常行为。</p><p>上述这些寄存器储存大小都是32位，即4字节。若想访问其低16位，可以把前面的 e 去掉，比如 <code>ax</code> <code>si</code> 等等。</p><p>针对x64架构，这些寄存器全部由 r 打头，如 <code>rax</code> ，储存空间变为64位。另外，x64还新增了8个通用寄存器，即 <code>r8-r15</code></p><table><thead><tr><th>64</th><th>低32</th><th>低16</th><th>低8</th></tr></thead><tbody><tr><td>rax</td><td>eax</td><td>ax</td><td>al</td></tr><tr><td>rbx</td><td>ebx</td><td>bx</td><td>bl</td></tr><tr><td>rcx</td><td>ecx</td><td>cx</td><td>cl</td></tr><tr><td>rdx</td><td>edx</td><td>dx</td><td>dl</td></tr><tr><td>rsi</td><td>esi</td><td>si</td><td>sil</td></tr><tr><td>rdi</td><td>edi</td><td>di</td><td>dil</td></tr><tr><td>rbp</td><td>ebp</td><td>bp</td><td>bpl</td></tr><tr><td>rsp</td><td>esp</td><td>sp</td><td>spl</td></tr><tr><td>r8</td><td>r8d</td><td>r8w</td><td>r8b</td></tr><tr><td>r9</td><td>r9d</td><td>r9w</td><td>r9b</td></tr><tr><td>r10</td><td>r10d</td><td>r10w</td><td>r10b</td></tr><tr><td>r11</td><td>r11d</td><td>r11w</td><td>r11b</td></tr><tr><td>r12</td><td>r12d</td><td>r12w</td><td>r12b</td></tr><tr><td>r13</td><td>r13d</td><td>r13w</td><td>r13b</td></tr><tr><td>r14</td><td>r14d</td><td>r14w</td><td>r14b</td></tr><tr><td>r15</td><td>r15d</td><td>r15w</td><td>r15b</td></tr></tbody></table><p><code>ax-dx</code> 可访问其高八位为 <code>ah-dh</code></p><h3 id="标志位寄存器">标志位寄存器</h3><p>这个寄存器中有很多标志位，用于储存cpu执行指令的一些状态。</p><figure><img src="659280-20201021092122855-1111960429.png" srcset="/img/loading.gif" lazyload alt="标志位寄存器各个标志位"><figcaption aria-hidden="true">标志位寄存器各个标志位</figcaption></figure><h3 id="指令寄存器">指令寄存器</h3><p>x86下指令寄存器叫 <code>eip</code> ，x64下叫 <code>rip</code> ，他们存放着cpu下一条指令所存放的地址， pwn中劫持程序控制流本质上就是修改指令寄存器到期望的地址而完成的。</p><h3 id="段寄存器">段寄存器</h3><p>x86和x64架构都有如下几个段寄存器，它们都是16位的</p><ul><li>cs 代码段</li><li>ds 数据段</li><li>ss 栈段</li><li>es 拓展段</li><li>fs 数据段</li><li>gs 数据段</li></ul><p>段寄存器的知识略显复杂，尤其在x86和x64的保护模式下，暂且不论。有兴趣的同学可以参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuanyuan/p/13850548.html">一口气看完45个寄存器，CPU核心技术大揭秘</a></p><h2 id="认识一些常见的指令">认识一些常见的指令</h2><h3 id="mov">mov</h3><p>我们先来根据上面 <code>helloworld.asm</code> 程序来讲解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nasm">_start:                               <br>        mov edx, len                <br>        mov ecx, msg                <br>        mov ebx, 1                  <br>        mov eax, 4                  <br>        int 0x80                    <br><br>        mov ebx, 1                  <br>        mov eax, 1                   <br>        int 0x80                    <br></code></pre></td></tr></table></figure><p>首先是 <code>mov</code> 指令，格式为 <code>mov a,b</code> ，用c语言类比则是 <code>a=b;</code> 。在intel风格的语法中（也就是现在我们展示的语法），<code>a</code> 叫做<strong>目的操作数</strong> ，<code>b</code> 叫做<strong>源操作数</strong>。目的操作数和源操作数有一定的规则，以下语法允许的：</p><table><thead><tr><th>源操作数 <code>b</code></th><th>目的操作数 <code>a</code></th></tr></thead><tbody><tr><td>立即数</td><td>寄存器</td></tr><tr><td>立即数</td><td>内存</td></tr><tr><td>寄存器</td><td>寄存器</td></tr><tr><td>寄存器</td><td>内存</td></tr><tr><td>内存</td><td>寄存器</td></tr></tbody></table><p>注：在intel风格语法中，目的操作数在前，源操作数在后；在AT&amp;T语法中，目的操作数在后，源操作数在前。</p><p><strong>立即数</strong>：cpu将指令的一部分解释成数据，这部分数据称为立即数。比如说 <code>mov ebx, 1</code> 中的 <code>1</code> 即为立即数。如果你查看 <code>mov ebx, 1</code> 的机器码（<code>bb 01 00 00 00</code>），你会发现这部分数据确实是存在于指令中的。</p><p>在这里，你可能会对上面的机器码有所疑问，在这里先做解答：</p><ul><li>为什么1是四字节？因为ebx是四字节的寄存器。</li><li>为什么1是倒序的？因为遵循小端序储存。小端序是指一个整数储存在内存中时，其低位（偏小的位）对应低地址，高位对应高地址。上面指令中 <code>bb</code> 端是低地址方向，所以 <code>1</code> 储存在低地址方向。</li><li>为什么是<code>01</code>而不是<code>10</code>？因为显示的时候以一个字节为单位进行显示，事实上其二进制应为 <code>1000 0000</code></li></ul><p>那么<strong>内存</strong>是怎么体现的？</p><p>在nasm语法中，<code>[...]</code> 用以表示取 <code>...</code> 的值作为地址，该地址中的值，<code>...</code>是一个有效表达式。比如 <code>mov eax,[ebx]</code> 约等于c语言中的 <code>eax=*ebx</code> ，相当于 <code>ebx</code> 是一个指针。下面举出一些例子供大家体会：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nasm">mov eax,[ebx*2+ecx+2]<br>mov eax,[ebx*5]<br>;下面使用了标签<br>mov ebx,[label1+label2*2]<br></code></pre></td></tr></table></figure><p><strong>标签</strong>：在nasm语法中，你可以在数据声明或指令前面写一个<strong>标签</strong>，你在编程中可以引用这个标签，这等价于引用此处指令或声明的地址。</p><p>例如 <code>helloworld.asm</code> 中，<code>msg</code> 和 <code>_start</code> 都是标签。标签可以加冒号，也可以不加冒号。标签会在数据引用和跳转上带来极大的便利。</p><p><strong>常量</strong></p><p><em><code>equ</code> 定义一个符号，代表一个常量值：当使用 <code>equ</code> 时，源文件行上必须包含一个label。 <code>equ</code> 的行为就是把给出的label的名字定义成它的操作数(唯一)的值。该定义是不可更改的。</em></p><p>上述 <code>helloworld.asm</code> 中的 <code>len</code> 就是一个例子。它相当于在编译期间将所有 <code>len</code> 都换成一个立即数。</p><h3 id="int-0x80">int 0x80</h3><p>经过上面的学习，你应该已经了解了 <code>_start</code> 标签下面4行汇编指令的意思，接着的指令是 <code>int 0x80</code>。它向系统发出 <code>0x80</code> 的<strong>软中断</strong>指令，使系统进入<strong>内核态</strong> ，并根据一些<strong>通用寄存器</strong>中的值进行<strong>系统调用</strong>。你可以理解为调用操作系统（linux）的函数。</p><p>进行系统调用时，<code>eax</code> 储存的是<strong>系统调用号</strong>，并分别由 <code>ebx</code> 、<code>ecx</code> 、<code>edx</code> 、<code>esi</code> 、<code>edi</code> 传递第1-5个参数。<strong>系统调用号</strong>决定了调用系统哪个函数。</p><p>在本例中，前面一段的系统调用号是 <code>4</code> ，写成c语言是 <code>write(stdout,msg,len);</code> ，而下面一段则是 <code>exit(0);</code> 。</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Nashi_Ko/article/details/120288385">Linux X86架构 32 64系统调用表</a></p><h3 id="针对-helloworld.asm-的其他东西">针对 <code>helloworld.asm</code> 的其他东西</h3><h4 id="section">section</h4><p><code>section</code> 是一个伪指令，用于表示声明一个段，如数据段、代码段、bss段等，这与<strong>程序运行时内存分布</strong>相对应。</p><h4 id="global">global</h4><p><code>global</code> 也是一个伪代码，表示导出符号到其他模块。</p><h4 id="数据声明">数据声明</h4><p>在声明以初始化的数据的时候，<code>db</code> <code>dw</code> <code>dd</code> <code>dq</code> 分别代表以1、2、4、8个字节为单位，前面需要加上一个标签，相当于指针。</p><p>相对的，声明未初始化数据的时候（声明在bss段） ，使用 <code>resb</code> <code>resw</code> <code>resd</code> <code>resq</code>，后面加上以前面声明类型为单位的数据量，比如 <code>label1 resb 64</code> （声明一个64字节的未初始化变量）。</p><h4 id="与">$与$$</h4><p>$表示从它所在源代码行在编译后的起始地址，$$表示从当前段的起始地址。</p><p>所以 <code>$-msg</code> 表达的是当前源码地址减去 <code>msg</code> 起始地址，即得到 <code>msg</code> 字符串长度</p><h3 id="lea">lea</h3><p><code>lea</code> 指令用于加载有效地址，用法如下：</p><ul><li><code>lea eax,[401080h]</code> 将一个地址 <code>401080h</code> 写入 <code>eax</code></li><li><code>lea eax,dword [ebx]</code> 将储存了地址的 <code>ebx</code> 中的值写入 <code>eax</code></li><li><code>lea eax, [ebx+ecx*4+8]</code> 计算 <code>ebx+ecx*4+8</code> 的地址并写入 <code>eax</code></li></ul><p>在x64架构中也同理。</p><h3 id="算数指令逻辑指令">算数指令、逻辑指令</h3><p>我们只先提及下面会用到的，其他指令建议自学了解。</p><ul><li><code>add a,b</code> 相当于 <code>a=a+b</code> ，其中 <code>a</code> 可以是一个寄存器或内存地址，<code>b</code> 可以是一个立即数、寄存器或内存地址。</li><li><code>sub a,b</code> 相减，与上面同理。</li></ul><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40179091/article/details/131768536">asm:常见指令大全</a></p><h3 id="栈与函数">栈与函数</h3><p>这里的<strong>栈</strong>指的是程序运行时的栈，它由栈基址寄存器 <code>ebp</code> 和栈顶寄存器 <code>esp</code> 来管理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">00:0000│ rsp  0x7fffffffd640 ◂— 0x55460000000000<br>01:0008│      0x7fffffffd648 ◂— 0x85ddfd55f4464e00<br>02:0010│ rbp  0x7fffffffd650 ◂— 0x1<br>03:0018│      0x7fffffffd658 —▸ 0x7ffff7dd9d68 (__libc_start_call_main+120) ◂— mov edi, eax<br>04:0020│      0x7fffffffd660 —▸ 0x7fffffffd750 —▸ 0x7fffffffd758 ◂— 0x38 /* &#x27;8&#x27; */<br>05:0028│      0x7fffffffd668 —▸ 0x5555555551e6 (main) ◂— endbr64<br>06:0030│      0x7fffffffd670 ◂— 0x155554040<br></code></pre></td></tr></table></figure><p>这是一个64位程序main函数的栈（使用插件pwndbg）</p><ul><li><code>push</code> 可以接一个立即数或一个寄存器操作数，将一个值压入栈中。 例： <code>push eax</code> 等效于 <code>sub esp,4; mov [esp],eax</code></li><li><code>pop</code> 接一个寄存器，将栈中的值弹入寄存器中。 例：<code>pop eax</code> 等效于 <code>mov eax,[esp]; add esp,4</code></li><li><code>leave</code> 不接任何东西，在一个函数结束的时候调用。 例：<code>leave</code> 等效于 <code>mov esp,ebp; pop ebp</code></li><li><code>call</code> 调用一个函数，后面接一个地址（或者说是标签）。 例：<code>call printf</code> 等效于 <code>push eip; jmp printf</code></li><li><code>ret</code> 从一个函数中返回到原来的执行位置，什么也不接。 例：<code>ret</code> 等效于 <code>pop eip</code></li></ul><p>可以通过上节课的 <code>overflow32</code> 程序逆向了解栈帧。</p><p>另，下面是一段经典的x86的shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nasm">section .text<br>global _start<br>_start:<br>    xor    eax,eax<br>    push   eax<br>    push   0x68732f2f<br>    push   0x6e69622f<br>    mov    ebx,esp<br>    mov    ecx,eax<br>    mov    edx,eax<br>    mov    al,0xb<br>    int    0x80<br>    xor    eax,eax<br>    inc    eax<br>    int    0x80<br></code></pre></td></tr></table></figure><p>编译链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nasm -f elf32 shellcode.asm -o shellcode.o<br>ld shellcode.o -o shellcode -m elf_i386<br></code></pre></td></tr></table></figure><h3 id="比较与跳转">比较与跳转</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zmmycsdn/article/details/78511948">汇编跳转指令: JMP、JECXZ、JA、JB、JG、JL、JE、JZ、JS、JC、JO、JP 等</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/WolvenSec/article/details/139244132">汇编：比较&amp;跳转</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/binary/" class="category-chain-item">binary</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/binary/" class="print-no-link">#binary</a> <a href="/tags/pwn/" class="print-no-link">#pwn</a> <a href="/tags/ctf/" class="print-no-link">#ctf</a> <a href="/tags/asm/" class="print-no-link">#asm</a></div></div><div class="license-box my-3"><div class="license-title"><div>汇编简介</div><div>https://dx3906999.github.io/2024/12/05/binary-2024-introduction-to-asm/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>dx3qOb</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年12月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/12/05/binary-2024-stack-and-function/" title="栈与函数"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">栈与函数</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/05/30/discrete-mathematics-graph-theory/" title="离散数学——图论总结归纳"><span class="hidden-mobile">离散数学——图论总结归纳</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><script type="text/javascript">Fluid.utils.loadComments("#comments",function(){var t="github-light",e="github-dark",s="dark"===(s=document.documentElement.getAttribute("data-user-color-scheme"))?e:t;window.UtterancesThemeLight=t,window.UtterancesThemeDark=e;var n=document.createElement("script");n.setAttribute("src","https://utteranc.es/client.js"),n.setAttribute("repo","dx3906999/myblog-utterances-comments"),n.setAttribute("issue-term","pathname"),n.setAttribute("label","utterances"),n.setAttribute("theme",s),n.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(n)})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>